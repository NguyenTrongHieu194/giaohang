<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bảng điều khiển Shipper/Tài xế</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        .card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .btn-primary {
            background-color: #4f46e5;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-danger {
            background-color: #dc2626;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        .btn-secondary {
            background-color: #6b7280;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .btn-secondary:hover {
            background-color: #4b5563;
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <header class="bg-white shadow-md py-4">
        <div class="container flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Bảng điều khiển Shipper/Tài xế</h1>
            <button id="logoutButton" class="btn-danger">Đăng xuất</button>
        </div>
    </header>

    <main class="flex-grow container mt-8">
        <section id="pendingRequests" class="mb-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Yêu cầu cần có sẵn</h2>
            <div id="requestsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Requests will be loaded here by JavaScript -->
                <p id="noPendingRequests" class="text-gray-500 col-span-full hidden">Hiện chưa có yêu cầu nào đang hoạt động.</p>
            </div>
        </section>

        <section id="myRequests">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Yêu cầu của tôi</h2>
            <div id="myRequestsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- My accepted requests will be loaded here by JavaScript -->
                <p id="noMyRequests" class="text-gray-500 col-span-full hidden">Bạn chưa có yêu cầu nào đang hoạt động.</p>
            </div>
        </section>
    </main>

    <!-- Modal for messages -->
    <div id="messageModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <p id="modalMessage" class="text-lg font-medium text-gray-800"></p>
            <button id="modalCloseButton" class="btn-primary mt-4">Đóng</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, where, onSnapshot, doc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const functions = getFunctions(app, 'us-central1'); // Specify region for Cloud Functions

        let currentUserId = null; // To store the authenticated user's UID
        let currentUserRole = null; // To store the authenticated user's role

        // Elements
        const requestsList = document.getElementById('requestsList');
        const myRequestsList = document.getElementById('myRequestsList');
        const noPendingRequests = document.getElementById('noPendingRequests');
        const noMyRequests = document.getElementById('noMyRequests');
        const logoutButton = document.getElementById('logoutButton');

        // Modal elements
        const messageModal = document.getElementById('messageModal');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const closeButton = document.querySelector('.close-button');

        // Show modal function
        function showModal(message) {
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }

        // Hide modal function
        function hideModal() {
            messageModal.style.display = 'none';
        }

        // Event listeners for modal
        modalCloseButton.addEventListener('click', hideModal);
        closeButton.addEventListener('click', hideModal);
        window.addEventListener('click', (event) => {
            if (event.target == messageModal) {
                hideModal();
            }
        });

        // Handle logout
        logoutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                showModal('Đăng xuất thành công!');
                // Redirect or update UI after logout
                window.location.href = '/'; // Redirect to home or login page
            } catch (error) {
                console.error('Lỗi khi đăng xuất:', error);
                showModal('Lỗi khi đăng xuất: ' + error.message);
            }
        });

        // Function to render requests
        function renderRequest(request, container, isMyRequest = false) {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
                <h3 class="text-lg font-semibold text-gray-800 mb-2">Yêu cầu ${request.type === 'food_order' ? 'giao hàng' : request.type === 'shipper_request' ? 'shipper' : 'chuyến đi'}</h3>
                <p class="text-gray-600">Từ: ${request.pickupLocation}</p>
                <p class="text-gray-600">Đến: ${request.deliveryLocation}</p>
                <p class="text-gray-600">Gói: ${request.packageDetails || request.vehicleType || 'N/A'}</p>
                <p class="text-gray-600">Thời gian: ${new Date(request.timestamp.seconds * 1000).toLocaleString()}</p>
                <p class="text-gray-700 font-medium mt-2">Trạng thái: <span id="status-${request.id}">${request.status}</span></p>
                ${!isMyRequest && request.status === 'Đang tìm shipper' ? `
                    <div class="mt-4 flex space-x-2">
                        <button id="accept-${request.id}" class="btn-primary flex-1">Chấp nhận</button>
                        <button id="reject-${request.id}" class="btn-secondary flex-1">Từ chối</button>
                    </div>
                ` : ''}
            `;
            container.appendChild(card);

            if (!isMyRequest && request.status === 'Đang tìm shipper') {
                document.getElementById(`accept-${request.id}`).addEventListener('click', () => {
                    acceptRequest(request.userId, request.collectionName, request.id, request.type);
                });
                document.getElementById(`reject-${request.id}`).addEventListener('click', () => {
                    rejectRequest(request.userId, request.collectionName, request.id);
                });
            }
        }

        // Function to accept a request via Cloud Function
        async function acceptRequest(userId, collectionName, requestId, type) {
            // Lấy ID Token từ người dùng hiện tại và log nó
            const clientSideIdToken = await auth.currentUser.getIdToken();
            console.log("Client-side ID Token before calling Cloud Function (first 20 chars):", clientSideIdToken.substring(0, 20) + "...");
            console.log("Client-side ID Token (full):", clientSideIdToken); // Chỉ log đầy đủ để debug, không nên làm trong production

            try {
                const acceptRequestCallable = functions.httpsCallable('acceptRequest');
                const result = await acceptRequestCallable({
                    userId: userId,
                    collectionName: collectionName,
                    requestId: requestId,
                    type: type,
                    idToken: clientSideIdToken // Đảm bảo bạn đang gửi idToken qua data payload
                });
                showModal(result.data.message);
            } catch (error) {
                console.error('Lỗi khi gọi Cloud Function:', error);
                showModal('Lỗi khi chấp nhận yêu cầu: ' + error.message);
            }
        }

        // Function to reject a request (simple client-side update for now)
        async function rejectRequest(userId, collectionName, requestId) {
            try {
                const requestRef = doc(db, `artifacts/${appId}/users/${userId}/${collectionName}`, requestId);
                await updateDoc(requestRef, {
                    status: 'Đã từ chối'
                });
                showModal('Yêu cầu đã được từ chối.');
            } catch (error) {
                console.error('Lỗi khi từ chối yêu cầu:', error);
                showModal('Lỗi khi từ chối yêu cầu: ' + error.message);
            }
        }

        // Main function to listen for requests
        async function listenForRequests() {
            // Ensure user is authenticated before setting up listeners
            if (!currentUserId || !currentUserRole) {
                console.log("User not authenticated or role not set. Skipping Firestore listeners.");
                return;
            }

            // Listen for pending requests (orders, shipper_requests, ride_requests)
            const allCollections = ['orders', 'shipper_requests', 'ride_requests'];
            allCollections.forEach(collectionName => {
                const q = query(
                    collection(db, `artifacts/${appId}/users/${currentUserId}/${collectionName}`),
                    where('status', '==', 'Đang tìm shipper') // Only show pending requests
                );

                onSnapshot(q, (snapshot) => {
                    let hasPendingRequests = false;
                    requestsList.innerHTML = ''; // Clear previous requests
                    snapshot.forEach((doc) => {
                        const request = { id: doc.id, collectionName: collectionName, ...doc.data() };
                        // Only show requests that are not assigned to the current user
                        // and are of the type relevant to the user's role
                        if ((request.type === 'food_order' || request.type === 'shipper_request') && currentUserRole === 'shipper') {
                            if (!request.assignedShipperId || request.assignedShipperId === currentUserId) {
                                renderRequest(request, requestsList);
                                hasPendingRequests = true;
                            }
                        } else if (request.type === 'ride_request' && currentUserRole === 'driver') {
                            if (!request.assignedDriverId || request.assignedDriverId === currentUserId) {
                                renderRequest(request, requestsList);
                                hasPendingRequests = true;
                            }
                        }
                    });
                    noPendingRequests.classList.toggle('hidden', hasPendingRequests);
                });
            });

            // Listen for requests assigned to the current user
            // This part needs to query across all users' subcollections to find requests assigned to currentUserId
            // This is complex for Firestore and might require denormalization or a different query structure.
            // For simplicity, we'll assume 'my requests' are also stored under the current user's path,
            // but with an 'assigned' status.
            
            // For 'my requests', we'll listen for requests where the assigned ID matches currentUserId
            allCollections.forEach(collectionName => {
                const qMy = query(
                    collection(db, `artifacts/${appId}/users/${currentUserId}/${collectionName}`),
                    where('assignedShipperId', '==', currentUserId) // For shipper/food_order
                );
                const qMyDriver = query(
                    collection(db, `artifacts/${appId}/users/${currentUserId}/${collectionName}`),
                    where('assignedDriverId', '==', currentUserId) // For ride_request
                );

                onSnapshot(qMy, (snapshot) => {
                    let hasMyRequests = false;
                    // Filter to avoid duplicating if both queries hit the same document
                    const processedRequestIds = new Set(); 
                    snapshot.forEach((doc) => {
                        if (!processedRequestIds.has(doc.id)) {
                            const request = { id: doc.id, collectionName: collectionName, ...doc.data() };
                            // Ensure it's a shipper-relevant request
                            if (request.type === 'food_order' || request.type === 'shipper_request') {
                                renderRequest(request, myRequestsList, true);
                                hasMyRequests = true;
                                processedRequestIds.add(doc.id);
                            }
                        }
                    });
                    noMyRequests.classList.toggle('hidden', hasMyRequests);
                });

                onSnapshot(qMyDriver, (snapshot) => {
                    let hasMyRequests = false;
                    snapshot.forEach((doc) => {
                        if (!processedRequestIds.has(doc.id)) { // Check if already processed by previous query
                            const request = { id: doc.id, collectionName: collectionName, ...doc.data() };
                            // Ensure it's a driver-relevant request
                            if (request.type === 'ride_request') {
                                renderRequest(request, myRequestsList, true);
                                hasMyRequests = true;
                                processedRequestIds.add(doc.id);
                            }
                        }
                    });
                    noMyRequests.classList.toggle('hidden', hasMyRequests);
                });
            });
        }

        // Firebase Auth State Listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                // User is signed in.
                currentUserId = user.uid;
                try {
                    // Get custom claims to determine user role
                    const idTokenResult = await user.getIdTokenResult();
                    currentUserRole = idTokenResult.claims.role;
                    console.log("User authenticated:", currentUserId, "Role:", currentUserRole);
                    listenForRequests(); // Start listening for requests once user is authenticated and role is known
                } catch (error) {
                    console.error("Error getting ID token result or custom claims:", error);
                    showModal("Lỗi xác thực người dùng: " + error.message);
                    await signOut(auth); // Force sign out if claims cannot be retrieved
                }
            } else {
                // User is signed out.
                currentUserId = null;
                currentUserRole = null;
                requestsList.innerHTML = '';
                myRequestsList.innerHTML = '';
                noPendingRequests.classList.remove('hidden');
                noMyRequests.classList.remove('hidden');
                console.log("User is signed out.");
                // Redirect to login page if not already there
                // window.location.href = '/'; 
            }
        });

        // Initial anonymous sign-in if no token is provided (for local dev/testing)
        // In a real app, you'd likely have a dedicated login page.
        if (!auth.currentUser && !initialAuthToken) {
            signInAnonymously(auth).then(() => {
                console.log("Signed in anonymously (no initial token provided).");
            }).catch((error) => {
                console.error("Error signing in anonymously:", error);
                showModal("Lỗi đăng nhập ẩn danh: " + error.message);
            });
        } else if (initialAuthToken) {
            // Use the provided custom token for sign-in
            signInWithCustomToken(auth, initialAuthToken).then(() => {
                console.log("Signed in with custom token.");
            }).catch((error) => {
                console.error("Error signing in with custom token:", error);
                showModal("Lỗi đăng nhập bằng token tùy chỉnh: " + error.message);
            });
        }
    </script>
</body>
</html>
